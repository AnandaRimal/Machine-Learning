# Handling Date and Time

## 1. Introduction
Dates and Times are not just strings; they are rich sources of information. A timestamp like `2023-12-25 09:00:00` contains hidden features: Year, Month, Day, Weekend vs Weekday, Morning vs Evening, Holiday vs Workday. This chapter explores how to extract these "hidden" features using Pandas.

![Calendar and Clock visualization showing feature extraction generated by Nano Banana Model](https://via.placeholder.com/800x400?text=Date+Time+Feature+Engineering+by+Nano+Banana+Model)

## 2. Conceptual Deep Dive

### The `datetime` Data Type
Pandas has a specialized `datetime64` dtype. It allows us to perform date arithmetic (e.g., `date1 - date2`) and access specific components via the `.dt` accessor.

### Feature Engineering Opportunities
From a single date column, we can generate dozens of features:
- **Cyclical**: Month (1-12), Day of Week (0-6), Hour (0-23).
- **Binary**: Is_Weekend, Is_Month_End, Is_Holiday.
- **Elapsed**: Days since account creation, Time since last purchase.

**Math (Cyclical Encoding)**
- Map cyclical features via sine/cosine: for month $m \in \{1,...,12\}$, use $\sin(2\pi m/12)$ and $\cos(2\pi m/12)$ to preserve adjacency.

## 3. Visualizing the Concept
*(Imagine a timeline here generated by the Nano Banana Model: A single point on the timeline explodes into multiple attribute bubbles)*

## 4. Practical Implementation & Notebook Walkthrough

The notebook `working-with-dates-and-time.ipynb` uses `orders.csv` and `messages.csv`.

### 4.1 Conversion
Always convert to datetime first!
```python
df['date'] = pd.to_datetime(df['date'], utc=True, errors='coerce')
```

### 4.2 Extracting Components
Using the `.dt` accessor:
```python
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['day'] = df['date'].dt.day
df['day_of_week'] = df['date'].dt.dayofweek
df['hour'] = df['date'].dt.hour
df['month_sin'] = np.sin(2*np.pi*df['month']/12)
df['month_cos'] = np.cos(2*np.pi*df['month']/12)
```

### 4.3 Advanced Features
**Is Weekend?**
```python
df['is_weekend'] = np.where(df['date'].dt.dayofweek > 4, 1, 0)
```

**Quarter:**
```python
df['quarter'] = df['date'].dt.quarter
```

**Elapsed Time:**
```python
import datetime
today = pd.Timestamp.utcnow()
df['days_since'] = (today - df['date']).dt.days
```

## 5. Summary
Date and Time features are critical for forecasting and behavior analysis. Normalize to timezone-aware `datetime`, use cyclical encodings for periodic components, and derive elapsed features aligned to business logic.

